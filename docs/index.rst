Django Rest Framework SelectSerializer documentation
====================================================

Contents:

.. toctree::
   :maxdepth: 2


What
----

SelectSerializer is an extension for Django Rest Framework serializers.
It enables a pattern for including or excluding data to be returned by an endpoint.

An example is perhaps easiest.
Lets say you have a user endpoint that returns data about a user
and metadata on any documents belonging to that user.
The endpoint data is generated by a ``UserSerializer`` and a nested ``DocumentSerializer``::

    GET: /api/users/jdoe
    RESP:
    {
        "username": "jdoe",
        "first_name": "John",
        "last_name": "Doe",
        "docs": [
            {
                "title": "John Doe's Resume",
                "filename": "resume.pdf",
                "type": "pdf",
                "uploaded": "2014/01/01"
            },
            {
                "title": "Writing Sample",
                "filename": "sample.doc",
                "type": "doc",
                "uploaded": "2014/01/02"
            }
        ]
    }

Now, this endpoint response requires hitting the database to get both the user and all their docs.
But what if we don't need the docs?
We could create a whole new serializer and endpoint, or we could use SelectSerializer.
If we use SelectSerializers, we have very fine grained control over exactly what data is returned.
We can use the ``exclude`` parameter to exclude a bit of data::

    GET: /api/users/jdoe?exclude=docs
    RESP:
    {
        "username": "jdoe",
        "first_name": "John",
        "last_name": "Doe",
    }

We can use the ``select`` parameter to only return a bit of data::

    GET: /api/users/jdoe?select=last_name
    RESP:
    {
        "last_name": "Doe",
    }

We can select/exclude multiple bits of information by passing a comma-delimited list::

    GET: /api/users/jdoe?select=last_name,first_name
    RESP:
    {
        "first_name": "John",
        "last_name": "Doe",
    }

Finally, we can even select/exclude nested data by passing a dot-delimited path::

    GET: /api/users/jdoe?exclude=docs.type,docs.filename
    RESP:
    {
        "username": "jdoe",
        "first_name": "John",
        "last_name": "Doe",
        "docs": [
            {
                "title": "John Doe's Resume",
                "uploaded": "2014/01/01"
            },
            {
                "title": "Writing Sample",
                "uploaded": "2014/01/02"
            }
        ]
    }

Data not returned is completely eliminated from the serializer,
so any hits to the database or complex calculations necessary to render the data will never be performed.

How
---

Installation
^^^^^^^^^^^^

::

    pip install rest-framework-selectserializer

Usage
^^^^^

SelectSerializers are incredibly easy to use. 
If your model inherits from ``rest_framework.serializers.Serializer``,
instead inherit from ``selectserializer.serializers.SelectSerializer``.
If your model inherits from ``rest_framework.serializers.ModelSerializer``,
instead inherit from ``selectserializer.serializers.SelectModelSerializer``.
If your model inherits from some other type of serializer,
you can still enable select/exclude by mixing in ``selectserializer.serializers.SelectSerializerMixin``::

    from selectserializer.serializers import SelectSerializerMixin
    
    class MyCustomSerializer(SelectSerializerMixin, MyCustomBaseSerializer):
        ...

Once you have a select-enabled serializer whether by subclassing or mixin,
you can select/exclude things in one of two ways. First, you can directly
pass select/exclude arguments to the serializer on instantiation::

    serializer = MySelectSerializer(instance, data=request.DATA, select=['pathone', 'path.two'], exclude='path')

These can either be a list of dotted paths or a single path string.
Alternatively, and easier if you are using this in a view,
you can pass in a raw querydict::

    serializer = MySelectSerializer(instance, data=request.DATA, querydict=request.QUERY_PARAMS)

The serializer will look for ``select`` and ``exclude`` parameters in the querydict and properly filter the response.


Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

